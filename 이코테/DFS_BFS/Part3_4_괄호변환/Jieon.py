def solution(p):
    if p=='': #rule1 : 입력이 빈 문자열일 경우, 빈 문자열을 반환합니다.
        return p
    #rule 2: 문자열을 "균형잡힌 괄호 문자열" u,v로 분리합니다. 단, u는 더이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.
    b=0 #균형 확인 
    right=True #올바른 문자열 확인
    for i in range(len(p)):
        if p[i]=='(':
            b+=1
        elif p[i]==')':
            b-=1
        if b<0:
            right=False
        if b==0:
            break
    #u,v분리
    u=p[:i+1]
    v=p[i+1:]
    
    #rule3: 문자열 u가 "올바른 괄호 문자열" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 
    # 3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다. 
    if right:
        answer=u+solution(v) #v 재귀함수 실행
    
    #rule 4: 문자열 u가 "올바른 괄호 문자열"이 아니라면 아래 과정을 수행합니다.
    else:
        #4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. ')'를 다시 붙입니다.
        answer='('+solution(v)+')' 
        #u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다.
        nu=[]
        if len(u)>2:
            for i in u[1:-1]:
                if i=='(':
                    nu.append(')')
                else:
                    nu.append('(')
        nu=''.join(nu)
        answer+=nu
    
    #생성된 문자열 반환
    return answer
        
print(solution("()))((()"))

#답지안봄 (40분 소요)
#문제를 이해하기 어려웠다. 첵좀 읽어야겠다.
#생각보다 좀 어려웠다. 이건 dfs이긴 한데, 2차원이 아닌 1차원 그래프여서 조금 생각하기 어려웠다.
#u,v를 나눠서 v부터 변경하기 때문에 가장 먼 노드부터 변경이 시작되므로, 재귀함수를 사용해야 하고, dfs성격을 띄고 있다.